#include <SPI.h>
#include <WiFiNINA.h>
#include <NTPClient.h>


// // Define NTP Client to get time
// WiFiUDP ntpUDP;
// NTPClient timeClient(ntpUDP, "pool.ntp.org", 3600, 60000); // Change 3600 according to your timezone offset in seconds (e.g., -5*60*60 for EST)


#define TRIG_PIN1   9
#define ECHO_PIN1   8
#define TRIG_PIN2   7
#define ECHO_PIN2   6
#define G_LED   14
#define Y_LED   15
#define R_LED   16

char ssid[] = "yournetwork";        // your network SSID (name)
char pass[] = "yourpassword";    // your network password
int keyIndex = 0;                // your network key index number (needed only for WEP)

int status = WL_IDLE_STATUS;
WiFiServer server(80);

const int dirPin = 2;
const int stepPin = 3;
const int buttonPin1 = 4; // First button connected to pin 4 and GND
const int buttonPin2 = 5; // Second button connected to pin 5 and GND
float duration1_us, distance1_cm, duration2_us, distance2_cm, mindistance_cm;
int motstatus = 0; // Data collection only happens when this is activated after motors are used
int fill = 0; // Texts are only sent the first time fill lines are passed

struct SensorLog {
  String dateTime;
  float distance;
  bool requiringPickup;
};

SensorLog logs[10]; // Array to store the last 10 logs
int logIndex = 0; // Index to keep track of the next log position

void setup() {
  // Declare pins as Outputs
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  Serial.println("Access Point Web Server");
 
  pinMode(stepPin, OUTPUT);
  pinMode(dirPin, OUTPUT);
  // Declare the button pins as an Input with internal pull-up resistors
  pinMode(buttonPin1, INPUT_PULLUP);
  pinMode(buttonPin2, INPUT_PULLUP);
  // Set motor direction (HIGH for clockwise, LOW for counterclockwise)
  digitalWrite(dirPin, HIGH);
  // begin serial port
  // Configure sensor pins
  pinMode(TRIG_PIN1, OUTPUT);
  pinMode(ECHO_PIN1, INPUT);
  pinMode(TRIG_PIN2, OUTPUT);
  pinMode(ECHO_PIN2, INPUT);
  // Configure LED pins
  pinMode(G_LED, OUTPUT);
  pinMode(Y_LED, OUTPUT);
  pinMode(R_LED, OUTPUT);


    // check for the WiFi module:
  if (WiFi.status() == WL_NO_MODULE) {
    Serial.println("Communication with WiFi module failed!");
    // don't continue
    while (true);
  }

  String fv = WiFi.firmwareVersion();
  if (fv < WIFI_FIRMWARE_LATEST_VERSION) {
    Serial.println("Please upgrade the firmware");
  }
  // by default the local IP address will be 192.168.4.1
  // you can override it with the following:
  // WiFi.config(IPAddress(10, 0, 0, 1));

  // print the network name (SSID);
  Serial.print("Creating access point named: ");
  Serial.println(ssid);
  // Create open network. Change this line if you want to create an WEP network:
  status = WiFi.beginAP(ssid, pass);
  if (status != WL_AP_LISTENING) {
    Serial.println("Creating access point failed");
    // don't continue
    while (true);
  }
  // wait 10 seconds for connection:
  delay(10000);
  // start the web server on port 80
  server.begin();
  // you're connected now, so print out the status
  printWiFiStatus();
}

void loop() {
  // Check if both buttons are pressed
  // When pressed, the button pins should read LOW if wired to connect to GND when pressed
  // timeClient.update();
  WiFiClient client = server.available();
    if (client) {
      Serial.println("new client");
      while (client.connected()) {
        if (client.available()) {
          String currentLine = client.readStringUntil('\r');
          client.flush();

          // Send HTTP header
          if (currentLine.length() <= 1) {
            client.println("HTTP/1.1 200 OK");
            client.println("Content-type:text/html");
            client.println();
            // HTML content
            client.println("<!DOCTYPE html><html>");
            client.println("<head><meta http-equiv='refresh' content='5'/><title>Dhaka Sharps Disposal Bin</title></head>");
  
            }
            client.println("</table>");
            break; // Exit the loop after sending the response
          }
        }
      }
      client.stop();
      Serial.println("client disconnected");
    }


  int i=0;
  if(digitalRead(buttonPin1) == LOW && digitalRead(buttonPin2) == LOW) {
    digitalWrite(dirPin, HIGH);
    for(i; i <= 390; i++){
      if(digitalRead(buttonPin1) == LOW && digitalRead(buttonPin2) == LOW) {
        // Spin the motor as long as both buttons are pressed
        digitalWrite(stepPin, HIGH);
        delayMicroseconds(1000);
        digitalWrite(stepPin, LOW);
        delayMicroseconds(1000);
        digitalWrite(TRIG_PIN1, HIGH);
        delayMicroseconds(10);
        digitalWrite(TRIG_PIN1, LOW);
        delayMicroseconds(1000);
      }
      else{
        break;
      }
    }
  }
  while(i > 0){
    if(i == 390){
      delayMicroseconds(1000000);
    }
    motstatus = 1;
    digitalWrite(dirPin, LOW);
    // Spin the motor as long as both buttons are pressed
    digitalWrite(stepPin, HIGH);
    delayMicroseconds(1000);
    digitalWrite(stepPin, LOW);
    delayMicroseconds(1000);
    digitalWrite(TRIG_PIN1, HIGH);
    delayMicroseconds(10);
    digitalWrite(TRIG_PIN1, LOW);
    delayMicroseconds(200);
    i = i-1;
  }
  // Check if recently closed
  if(motstatus == 1){
    int avgdistance = 0;
    // Collect and average 30 sensor datapoints
    for(int j = 0; j<30; j++){
      // Produce a 10-microsecond pulse to the TRIG pin.
      digitalWrite(TRIG_PIN1, HIGH);
      delayMicroseconds(10);
      digitalWrite(TRIG_PIN1, LOW);
      // Measure the pulse duration from the ECHO pin
      duration1_us = pulseIn(ECHO_PIN1, HIGH);
      // Repeat
      digitalWrite(TRIG_PIN2, HIGH);
      delayMicroseconds(10);
      digitalWrite(TRIG_PIN2, LOW);
      duration2_us = pulseIn(ECHO_PIN2, HIGH);
      // calculate the distance
      distance1_cm = 0.017 * duration1_us;
      distance2_cm = 0.017 * duration2_us;
      mindistance_cm = min(distance1_cm, distance2_cm);
      // print the value to Serial Monitor
      // print the value to Serial Monitor
      avgdistance += mindistance_cm;
    }
    avgdistance = avgdistance / 30;
    Serial.print("distance: ");
    Serial.print(avgdistance);
    Serial.println(" cm");
    // If box is nearly full, loop so you don't reenable buttons
    while(avgdistance <= 5){
      // Turn off green/yellow LEDs, turn on red
      digitalWrite(G_LED, LOW);
      digitalWrite(Y_LED, LOW);
      digitalWrite(R_LED, HIGH);
      if(fill != 2){
        // Add code to send urgent text here
        fill = 2;
      }
      // Periodically recollect data to see if it has been emptied
      delay(300000);
      avgdistance = 0;
      for(int j = 0; j<30; j++){
        // Produce a 10-microsecond pulse to the TRIG pin.
        digitalWrite(TRIG_PIN1, HIGH);
        delayMicroseconds(10);
        digitalWrite(TRIG_PIN1, LOW);
        // Measure the pulse duration from the ECHO pin
        duration1_us = pulseIn(ECHO_PIN1, HIGH);
        // Repeat
        digitalWrite(TRIG_PIN2, HIGH);
        delayMicroseconds(10);
        digitalWrite(TRIG_PIN2, LOW);
        duration2_us = pulseIn(ECHO_PIN2, HIGH);
        // calculate the distance
        distance1_cm = 0.017 * duration1_us;
        distance2_cm = 0.017 * duration2_us;
        mindistance_cm = min(distance1_cm, distance2_cm);
        // print the value to Serial Monitor
        // print the value to Serial Monitor
        avgdistance += mindistance_cm;
      }
      avgdistance = avgdistance / 30;
      Serial.print("distance: ");
      Serial.print(avgdistance);
      Serial.println(" cm");      
    }
    // If box is partially full turn on yellow light and send warning text
    if(avgdistance > 5 && avgdistance <= 10){
      digitalWrite(G_LED, LOW);
      digitalWrite(R_LED, LOW);
      digitalWrite(Y_LED, HIGH);
      if(fill != 1){
        // Add code to send warning text here
        fill = 1;
      }
    }
    // If box mostly empty turn on green light
    if(avgdistance > 10){
      digitalWrite(Y_LED, LOW);
      digitalWrite(R_LED, LOW);
      digitalWrite(G_LED, HIGH);
      fill = 0;
    }
    // Delay before reenabling door to give time to remove hands from buttons
    delayMicroseconds(2000000);
    // Reset box to neutral state
    motstatus = 0;

    bool requiringPickup = avgdistance <= 5;
  
  }


void printWiFiStatus() {
  // print the SSID of the network you're attached to:
  Serial.print("SSID: ");
  Serial.println(WiFi.SSID());
  // print your WiFi shield's IP address:
  IPAddress ip = WiFi.localIP();
  Serial.print("IP Address: ");
  Serial.println(ip);

  // print where to go in a browser:
  Serial.print("To see this page in action, open a browser to http://");
  Serial.println(ip);
}

void addLog(String dateTime, float distance, bool requiringPickup) {
  logs[logIndex].dateTime = dateTime;
  logs[logIndex].distance = distance;
  logs[logIndex].requiringPickup = requiringPickup;
  logIndex = (logIndex + 1) % 10; // Ensure the index wraps around
}



